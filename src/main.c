#include "megaman64.h"
#include "viint.h"

extern volatile s32 isSaveOrLoadActive;
extern u8 p1DpadInputs; //801C4450
extern u32 gTime;

s32 init = 0;

typedef struct CustomThread {
    /* 0x000 */ OSThread thread;
    /* 0x1B0 */ char stack[0xC000];
    /* 0x9B0 */ OSMesgQueue queue;
    /* 0x9C8 */ OSMesg mesg;
    /* 0x9CC */ u16* frameBuf;
    /* 0x9D0 */ u16 width;
    /* 0x9D2 */ u16 height;
} CustomThread; // size = 0x9D4

CustomThread gCustomThread = {0};

void savestateMain(void);
void loadstateMain(void);

extern __OSViContext vi[2];
extern __OSViContext* __osViCurr;
extern __OSViContext* __osViNext;

void osViRepeatLine(u8 active) {
    register u32 saveMask = __osDisableInt();

    if (active) {
        __osViNext->state |= VI_STATE_REPEATLINE;
    } else {
        __osViNext->state &= ~VI_STATE_REPEATLINE;
    }

    __osRestoreInt(saveMask);
}

void savestateCheckMain(void) {
    // if (p1DpadInputs == 1) {
    //     isSaveOrLoadActive = 1;
    //     osCreateThread(&gCustomThread.thread, 255, (void*)savestateMain, NULL,
    //             gCustomThread.stack + sizeof(gCustomThread.stack), 255);
    //     osStartThread(&gCustomThread.thread);

    // } else if (p1DpadInputs == 2) {
    //     isSaveOrLoadActive = 1;
    //     osCreateThread(&gCustomThread.thread, 255, (void*)loadstateMain, NULL,
    //             gCustomThread.stack + sizeof(gCustomThread.stack), 255);
    //     osStartThread(&gCustomThread.thread);
    // }

    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad2(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad3(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

//seems to make it worse?
void rdpWaitOnSaveOrLoad4(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

//seems to help?
void rdpWaitOnSaveOrLoad5(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

//seems to make it worse?
void rdpWaitOnSaveOrLoad6(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad7(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

u8 ciImage[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x21, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x22, 0x33, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x22, 0x33, 0x21, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x33, 0x33, 0x33, 0x24, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x13, 0x33, 0x33, 0x24, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x22, 0x22, 0x24, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x44, 0x44, 0x22, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x14, 0x44, 0x42, 0x21, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x14, 0x42, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x11, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x55, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

u16 palette[] = {0x1886, 0x20C9, 0x8BEB, 0x6AE3, 0xC5F7, 0x2883, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};

void func_80092560(void);
void func_800927A4(void);
void func_8009292C(Gfx*, s32, s32, s32);
void func_80092B10(void*);
void func_80092B70(void);
void func_80092C10(void*, s32);
extern void func_80092B50(void);
extern void func_80092D60(void*, s32);

extern s32 D_800A6970; //unk type
extern s32* D_801E0EF0; //unk type
extern s32 D_801E6CB0;
extern Gfx D_800A6980[];
extern u16* gFrameBufferPtrs[2];
extern u8* gDepthBufferPtr;

void func_80025C60_Hook(void) {
    Gfx sp10[257];

    func_80092B70();
    func_80092C10(gFrameBufferPtrs, 2);
    gDepthBufferPtr = (u8* )0x80000400;
    func_80092B10(func_80092B50);
    func_80092D60(&D_801E6CB0, 0x20000);
    D_801E0EF0 = &D_800A6970;
    func_800927A4();
    
    //jump an link to DL at D_800A6980
    sp10[0].words.w0 = (G_DL << 24);
    sp10[0].words.w1 = OS_K0_TO_PHYSICAL(D_800A6980);

    //full sync
    sp10[1].words.w0 = (G_RDPFULLSYNC << 24);
    sp10[1].words.w1 = 0;

    //end DL
    sp10[2].words.w0 = (G_ENDDL << 24);
    sp10[2].words.w1 = 0;
    
    func_8009292C(sp10, 0x18, 0, 0x40000);
    func_80092B70();
}

void func_80025D14_Hook(void) {
    Gfx sp10[256];

    func_80092560();
    func_80092B70();
    func_80092C10(gFrameBufferPtrs, 2);
    gDepthBufferPtr = (void*)0x80000400; //this cant be a symbol, is hardcoded to this address
    func_80092B10(&func_80092B50);
    func_80092D60(&D_801E6CB0, 0x20000);
    D_801E0EF0 = &D_800A6970;
    func_800927A4();

    //jump an link to DL at D_800A6980
    sp10[0].words.w0 = (G_DL << 24);
    sp10[0].words.w1 = OS_K0_TO_PHYSICAL(D_800A6980);

    //full sync
    sp10[1].words.w0 = (G_RDPFULLSYNC << 24);
    sp10[1].words.w1 = 0;

    //end DL
    sp10[2].words.w0 = (G_ENDDL << 24);
    sp10[2].words.w1 = 0;
    
    func_8009292C(sp10, 0x18, 0, 0x40000);
    func_80092B70();
}

void gfx_draw_rectangle2(int x, int y, int width, int height, u32 color){
    gDPSetCombineMode(gGfxMainPos++, G_CC_PRIMITIVE, G_CC_PRIMITIVE);
    gDPSetPrimColor(gGfxMainPos++,0,0,(color >> 24) & 0xFF,(color >> 16) & 0xFF,(color >> 8) & 0xFF,color & 0xFF);
    gDPPipeSync(gGfxMainPos++);
    gDPFillRectangle(gGfxMainPos++,x,y,x + width, y + height);
}

Gfx* gfx_printf_color(Gfx* gfx, u16 left, u16 top, u32 color, const char *format, ...);

//Gfx* drawCi4Image(Gfx* gfx, int x, int y, int width, int height, u8* texture, u16* palette)

void format_time_30fps(int frame_count, char* out_str) {
    // Convert frames to total milliseconds (1000 ms per second, 30 frames per second)
    int total_ms = (frame_count * 1000) / 30;

    int hours = total_ms / (60 * 60 * 1000);
    total_ms %= (60 * 60 * 1000);

    int minutes = total_ms / (60 * 1000);
    total_ms %= (60 * 1000);

    int seconds = total_ms / 1000;
    int milliseconds = total_ms % 1000;

    // Format: HR:MIN:SEC.MS
    sprintf(out_str, "%02d:%02d:%02d.%03d", hours, minutes, seconds, milliseconds);
}

extern s16 gCurHp; //8020CAEE
extern s16 gMaxHP; //8020CB30

//example of drawing right before
Gfx* DrawCustom(Gfx* gfxMain) {
    char buffer[64];

    if (init == 0) {
        init = 1;
        gfx_init();
        crash_screen_init();
    }

    
    _bzero(buffer, sizeof(buffer));

    format_time_30fps(gTime, buffer);
    //gfxMain = gfx_draw_rectangle(gfxMain, 0, 0, 80, 32, 0x000000FF);

    gDPSetScissor(gfxMain++, G_SC_NON_INTERLACE,
              0, 0, 320, 240);

    gDPSetOtherMode(gfxMain++, G_AD_DISABLE | G_CD_DISABLE |
        G_CK_NONE | G_TC_FILT |
        G_TD_CLAMP | G_TP_NONE |
        G_TL_TILE | G_TT_NONE |
        G_PM_NPRIMITIVE | G_CYC_1CYCLE |
        G_TF_BILERP, // HI
        G_AC_NONE | G_ZS_PRIM |
        G_RM_XLU_SURF | G_RM_XLU_SURF2); // LO
    // gfxMain = gfx_begin(gfxMain); //set up gfx for drawing text correctly

    // gfxMain = gfx_printf_color(gfxMain, 10,5, 0xFFFFFFFF, "%s", buffer); //draw the text
    // gfxMain = gfx_printf_color(gfxMain, 10,15, 0xFFFFFFFF, "HP: %d", gCurHp); //draw the text

    //gfxMain = gfx_printf_color(gfxMain, 10,15, 0xFFFFFFFF, "HP: %d", 0); //draw the text
    //return drawCi4Image(gGfxMainPos, 0, 0, 32, 32, ciImage, palette);

    return gfxMain; //return pointer to current gfx pointer so the game can full sync and end the DL
}
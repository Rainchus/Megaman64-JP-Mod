#include "megaman64.h"
#include "viint.h"

extern s32 gCamUnk; //some unknown camera parameter, related to position somehow?
//80033120: JAL memcpy //updates camera to player position
//8004DC84: JAL 0x80030A50 //somehow related to collision checking?
//8004DA84: JAL 0x8004DBEC //related to moving player

extern volatile s32 isSaveOrLoadActive;
extern u8 p1DpadInputs; //801C4450
extern u32 gTime;

extern Unk* D_80195300;
extern Unk2* D_801E0EF0;
extern volatile s32 D_80207C80;
extern s32 D_80218B20;
extern s32* D_80218CC0;
extern u32 D_800CF420;
extern u32 D_800CF424;
extern s32 D_800CF428;
extern u16 D_800CF434;
extern u16 D_80195304;
extern u16 D_80195306;
extern u32 D_801B7544;
extern OSMesgQueue D_8021D28C;
Gfx* DrawCustom(Gfx* gfxMain);

s32 init = 0;

typedef struct CustomThread {
    /* 0x000 */ OSThread thread;
    /* 0x1B0 */ char stack[0xC000];
    /* 0x9B0 */ OSMesgQueue queue;
    /* 0x9C8 */ OSMesg mesg;
    /* 0x9CC */ u16* frameBuf;
    /* 0x9D0 */ u16 width;
    /* 0x9D2 */ u16 height;
} CustomThread; // size = 0x9D4

CustomThread gCustomThread = {0};

Gfx* gfx_printf_color(Gfx* gfx, u16 left, u16 top, u32 color, const char *format, ...);
void savestateMain(void);
void loadstateMain(void);

extern __OSViContext vi[2];
extern __OSViContext* __osViCurr;
extern __OSViContext* __osViNext;

void osViRepeatLine(u8 active) {
    register u32 saveMask = __osDisableInt();

    if (active) {
        __osViNext->state |= VI_STATE_REPEATLINE;
    } else {
        __osViNext->state &= ~VI_STATE_REPEATLINE;
    }

    __osRestoreInt(saveMask);
}

void savestateCheckMain(void) {
    // if (p1DpadInputs == 1) {
    //     isSaveOrLoadActive = 1;
    //     osCreateThread(&gCustomThread.thread, 255, (void*)savestateMain, NULL,
    //             gCustomThread.stack + sizeof(gCustomThread.stack), 255);
    //     osStartThread(&gCustomThread.thread);

    // } else if (p1DpadInputs == 2) {
    //     isSaveOrLoadActive = 1;
    //     osCreateThread(&gCustomThread.thread, 255, (void*)loadstateMain, NULL,
    //             gCustomThread.stack + sizeof(gCustomThread.stack), 255);
    //     osStartThread(&gCustomThread.thread);
    // }

    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad2(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad3(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

//seems to make it worse?
void rdpWaitOnSaveOrLoad4(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

//seems to help?
void rdpWaitOnSaveOrLoad5(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

//seems to make it worse?
void rdpWaitOnSaveOrLoad6(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

void rdpWaitOnSaveOrLoad7(void) {
    while (isSaveOrLoadActive == 1) {

    }
}

u8 ciImage[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x21, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x22, 0x33, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x22, 0x33, 0x21, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x33, 0x33, 0x33, 0x24, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x13, 0x33, 0x33, 0x24, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x22, 0x22, 0x24, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x44, 0x44, 0x22, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x14, 0x44, 0x42, 0x21, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x14, 0x42, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x11, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x55, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

u16 palette[] = {0x1886, 0x20C9, 0x8BEB, 0x6AE3, 0xC5F7, 0x2883, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};

void func_80092560(void);
void func_800927A4(void);
void func_8009292C(Gfx*, s32, s32, s32);
void func_80092B10(void*);
void func_80092B70(void);
void func_80092C10(void*, s32);
extern void func_80092B50(void);
extern void func_80092D60(void*, s32);

extern Unk2 D_800A6970;
extern s32 D_801E6CB0;
extern Gfx D_800A6980[];
extern u16* gFrameBufferPtrs[2];
extern u8* gDepthBufferPtr;

void func_80025C60_Hook(void) {
    Gfx sp10[257];
    s32 i = 0;

    func_80092B70();
    func_80092C10(gFrameBufferPtrs, 2);
    gDepthBufferPtr = (u8* )0x80000400;
    func_80092B10(func_80092B50);
    func_80092D60(&D_801E6CB0, 0x20000);
    D_801E0EF0 = &D_800A6970;
    func_800927A4();
    
    gSPDisplayList(&sp10[i++], OS_K0_TO_PHYSICAL(D_800A6980));
    gDPFullSync(&sp10[i++]);
    gSPEndDisplayList(&sp10[i++]);
    
    func_8009292C(sp10, sizeof(Gfx) * i, 0, 0x40000);
    func_80092B70();
}

void func_80025D14_Hook(void) {
    Gfx sp10[256];
    s32 i = 0;

    func_80092560();
    func_80092B70();
    func_80092C10(gFrameBufferPtrs, 2);
    gDepthBufferPtr = (void*)0x80000400; //this cant be a symbol, is hardcoded to this address
    func_80092B10(&func_80092B50);
    func_80092D60(&D_801E6CB0, 0x20000);
    D_801E0EF0 = &D_800A6970;
    func_800927A4();

    gSPDisplayList(&sp10[i++], OS_K0_TO_PHYSICAL(D_800A6980));
    gDPFullSync(&sp10[i++]);
    gSPEndDisplayList(&sp10[i++]);
    
    func_8009292C(sp10, sizeof(Gfx) * i, 0, 0x40000);
    func_80092B70();
}

void format_time_30fps(int frame_count, char* out_str) {
    // Convert frames to total milliseconds (1000 ms per second, 30 frames per second)
    int total_ms = (frame_count * 1000) / 30;

    int hours = total_ms / (60 * 60 * 1000);
    total_ms %= (60 * 60 * 1000);

    int minutes = total_ms / (60 * 1000);
    total_ms %= (60 * 1000);

    int seconds = total_ms / 1000;
    int milliseconds = total_ms % 1000;

    // Format: HR:MIN:SEC.MS
    sprintf(out_str, "%02d:%02d:%02d.%03d", hours, minutes, seconds, milliseconds);
}

//draw game
void func_8009292C_Hook(Gfx* gfxData, s32 gfxDataSize, s32 arg2, u32 arg3) {
    u32 mask;

    u8* curDLPos = (u8*)gfxData;
    Gfx* endDLAddr;

    //parse DL commands to find full sync
    while (*curDLPos != 0xE9) {
        curDLPos += 8;
    }

    endDLAddr = (Gfx*)curDLPos;
    endDLAddr = DrawCustom(endDLAddr); //insert new DL data
    gDPFullSync(endDLAddr++);
    gSPEndDisplayList(endDLAddr++); //end DL
    gGfxMainPos = endDLAddr;

    gfxDataSize = (u8*)endDLAddr - (u8*)gfxData; //calculate new size with end - beginning

    D_80195300->unk40 = gfxData; //gfxData points to the beginning of the current display list to parse
    D_80195300->unk44 = gfxDataSize;
    D_80195300->unk14 = (arg3 >> 0x10);
    D_80195300->unk20 = D_801E0EF0[arg2].unk_00;
    D_80195300->unk28 = D_801E0EF0[arg2].unk_04;
    D_80195300->unk38 = D_800CF428;
    D_80195300->unk3C = D_800CF428 + ((D_800CF424 >> 3) * 8);
    D_80195300->unkC = D_80218B20;
    D_80195300->unk8 = (u16)arg3;
    
    if (D_800CF434 & 4) {
        D_800CF434 ^= 4;
        D_80195300->unk14 |= 2;
    }
    
    D_800CF434 = arg3;
    
    if (arg3 & 1) {
        D_80195300->unk54 = &D_80195306;
        D_801B7544 = (D_801B7544 + 1) % D_800CF420;
        D_80218B20 = D_80218CC0[D_801B7544];
        
    } else {
        D_80195300->unk54 = &D_80195304;
    }
    
    mask = osSetIntMask(1);
    D_80207C80++;
    osSetIntMask(mask);
    osWritebackDCacheAll();
    osSendMesg(&D_8021D28C, D_80195300, 1);
    D_80195300 = D_80195300->next;
}

extern s16 gCurHp; //8020CAEE
extern s16 gMaxHP; //8020CB30
Gfx* gfx_begin(Gfx*);
Gfx* gfx_draw_rectangle(Gfx* gfx, int x, int y, int width, int height, u32 color);

//example of drawing right before
Gfx* DrawCustom(Gfx* gfxMain) {
    char buffer[64];
    s32 yRoot = -2;

    if (init == 0) {
        init = 1;
        gfx_init();
        crash_screen_init();
    }

    format_time_30fps(gTime, buffer);

    gfxMain = gfx_begin(gfxMain); //set up gfx for drawing text correctly
    gfxMain = gfx_draw_rectangle(gfxMain, 0, 0, 110, 26 + yRoot, 0x000000FF);
    gfxMain = gfx_printf_color(gfxMain, 10,5 + yRoot, 0xFFFFFFFF, "%s", buffer); //draw current igt
    gfxMain = gfx_printf_color(gfxMain, 10,15 + yRoot, 0xFFFFFFFF, "HP: %d", gCurHp); //draw current hp

    //gfxMain = gfx_printf_color(gfxMain, 10,15, 0xFFFFFFFF, "HP: %d", 0); //draw the text
    //return drawCi4Image(gGfxMainPos, 0, 0, 32, 32, ciImage, palette);

    return gfxMain; //return pointer to current gfx pointer so the game can full sync and end the DL
}
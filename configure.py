import glob
import os
import ninja_syntax

# ----------------------------------------------------------------------
# 1. Collect source files
# ----------------------------------------------------------------------

# .c files are put into expansion-pak RAM
c_files = glob.glob('src/*.c', recursive=True)

# .s files are put into expansion-pak RAM and are *not* intended to have
# their headersize changed
s_files = glob.glob('asm/*.s', recursive=True)

# .asm files are assembly files that often change the headersize
asm_files = glob.glob('asm/*.asm', recursive=True)

# ✱ NEW: pre-built .o files that live in lib/
lib_obj_files = glob.glob('lib/**/*.a', recursive=True)  # recurse into sub-dirs

rom_name      = "rockmandash"
rom_mod_name  = f"{rom_name}.mod.z64"

# ----------------------------------------------------------------------
# 2. Fixed ARMIPS header/snippets
# ----------------------------------------------------------------------

header = f"""
// Automatically generated by configure.py, do not edit
.n64                                   // Tell armips we're targeting N64
.open "rom/{rom_name}.z64", "rom/{rom_mod_name}", 0
.definelabel PAYLOAD_ROM,  0x1FE0780
.definelabel PAYLOAD_VRAM, 0x80400000
"""

payload_start_text = """
.headersize PAYLOAD_VRAM - PAYLOAD_ROM
.org PAYLOAD_VRAM
PAYLOAD_START_RAM:
"""

footer = """
.align 8
PAYLOAD_END_RAM:
.close
"""

# ----------------------------------------------------------------------
# 3. Ninja build-file generation
# ----------------------------------------------------------------------

with open('build.ninja', 'w') as buildfile:
    ninja = ninja_syntax.Writer(buildfile)

    ninja.variable('CC', 'mips64-elf-gcc')
    ninja.variable(
        'STANDARDFLAGS',
        '-O2 -fno-inline -fno-unroll-loops -Wall -Wno-missing-braces '
        '-mtune=vr4300 -march=vr4300 -mabi=32 -fomit-frame-pointer '
        '-mno-abicalls -fno-pic -G0'
    )
    ninja.variable('INCLUDE_FLAGS', '-Iinclude -Isrc')

    ninja.rule(
        "cc",
        command="$CC $STANDARDFLAGS $INCLUDE_FLAGS -c $in -o $out",
        description="Compiling $in -> $out",
        depfile="$out.d",
        deps="gcc",
    )

    # ------------------------------------------------------------------
    # 3a. Build .c → obj
    # ------------------------------------------------------------------
    obj_files = []                        # everything the payload ultimately needs

    for c_file in c_files:
        obj_file = os.path.join('obj',
                                os.path.relpath(c_file, 'src')).replace('.c', '.o')
        ninja.build(obj_file, 'cc', c_file)
        obj_files.append(obj_file)

    # ------------------------------------------------------------------
    # 3b. Add pre-built lib object files to dependency graph
    #      (no rule – they already exist)
    # ------------------------------------------------------------------
    obj_files.extend(lib_obj_files)       # ✱ NEW

    # A single phony that represents “all objects are ready”
    ninja.build('all', 'phony', obj_files)

    # ------------------------------------------------------------------
    # 3c. ARMIPS, CRC, …
    # ------------------------------------------------------------------
    ninja.rule(
        "armips",
        command="armips asm/main.asm -sym syms.txt",
        description="Run armips"
    )
    ninja.build('run_armips', 'armips', 'all')

    ninja.rule(
        "n64crc",
        command=f"n64crc.exe rom/{rom_mod_name}",
        description="Fix N64 CRC"
    )
    ninja.build('run_n64crc', 'n64crc', 'run_armips')

# ----------------------------------------------------------------------
# 4. Generate asm/main.asm
# ----------------------------------------------------------------------

with open("asm/main.asm", 'w') as file:
    file.write(header)

    # Include stand-alone .asm chunks (except the driver we’re writing now)
    for asm_file in asm_files:
        if asm_file.endswith('main.asm'):
            continue
        file.write(f'.include "{asm_file}"\n')

    file.write(payload_start_text)

    # Include .s (raw assembly) files
    for s_file in s_files:
        file.write(f'.include "{s_file}"\n')

    # Import objects built from src/*.c
    for c_file in c_files:
        obj_file = os.path.join('obj',
                                os.path.relpath(c_file, 'src')).replace('.c', '.o')
        file.write(f'.importobj "{obj_file}"\n')

    # ✱ NEW: import pre-built lib/*.o objects
    for obj_file in lib_obj_files:
        file.write(f'.importobj "{obj_file}"\n')

    file.write(footer)
